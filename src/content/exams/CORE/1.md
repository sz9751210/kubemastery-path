---
id: 1
title: Container Basics
category: CORE
duration: 20 mins
---

# Task 1: Check Runtime Version
First, let's verify we are interacting with a CRI-compatible runtime.
Run the following command to check the version:

```bash
crictl version
```

```setup
# Ensure CRI is ready
crictl version > /dev/null 2>&1 || (echo "CRI not running" && exit 1)
```

```verify
crictl version | grep Runtime
```

# Task 2: Pull an Image
Unlike Docker, Kubernetes manages images for you. But you can manually pull images using `crictl` for debugging.
Pull the `busybox` image:

```bash
crictl pull busybox
```

```setup
# Clean up if exists
crictl rmi busybox 2>/dev/null || true
```

```verify
crictl images | grep busybox
```

# Task 3: Inspect Images
Verify that the image is available locally.

```bash
crictl images
```

```setup
# Ensure busybox is pulled
crictl pull busybox > /dev/null 2>&1
```

```verify
crictl images | grep busybox
```

# Task 4: Run a Pod via Kubectl
While `crictl` can run containers, it's complex. Let's use `kubectl` to start a workload, then we will inspect it with `crictl`.

```bash
kubectl run nginx-cri --image=nginx
```

```setup
# Clean up if exists
kubectl delete pod nginx-cri --force --grace-period=0 2>/dev/null || true
```

```verify
kubectl get pod nginx-cri | grep Running
```

# Task 5: Inspect Container with CRI
Now that the pod is running, let's find the underlying container using `crictl`.

```bash
crictl ps --name nginx-cri
```

```setup
# Ensure pod is running
kubectl run nginx-cri --image=nginx --dry-run=client -o yaml | kubectl apply -f -
kubectl wait --for=condition=Ready pod/nginx-cri --timeout=30s 2>/dev/null || true
```

```verify
crictl ps | grep nginx-cri
```
